---
comments: true
---

# Cryptographic Hashes

## 介绍

> 密码哈希/散列函数是一个函数H，当应用于消息时M时，可生成消息的固定长度的"指纹"

对消息的任何更改，无论多么小，都会更改哈希值的许多位，并且无法检测输出是如何根据特定输入来进行更改的。^^可以看成以某种看似随机的方式改变结果的哈希值^^

哈希函数$H(M)$ :

- 输入: 任意长度的消息M
- 输出: 固定长度的n位哈希值
- 有时也可写成$\{0,1\}^* \rightarrow \{0,1\}^n$

例如：SHA-256哈希算法可用于散列任何大小的消息，但总产生256位的散列值

## Hash属性

1. 正确性：Hash函数是确定的，即对相同的输入进行散列总是产生相同的输出
2. 计算效率非常高
3. 安全性:
      1. 单向性: 给出x很容易计算H(x)，然而给出输出y，不可能找到x，满足H(x) = y
      2. Collision-resistance：如果想找到$x \neq x'$,但$H(x) = H(x')$,不可能！
         - 即不可能找到任意两个哈希值相同的输入
       3. 随机/不可预测性: 对于改变输入如何影响输出没有可预测的模式 

## Hash算法

密码散列随着时间的推移而发展

最早的哈希函数之一[MD5](https://en.wikipedia.org/wiki/MD5)在2004年被[王小云](https://www.tsinghua.edu.cn/info/1167/93827.htm)破解(她的成就是找到了MD5迅速碰撞的方法) 

SHA1(安全哈希算法)在2017年被打破，也是被王小云破解(🧎‍♀膜拜️ --> [详见](http://www.xinhuanet.com/politics/2019-12/27/c_1125394020.htm) )

如今，常用的哈希算法主要有两个“家族”，它们被认为是安全的

- SHA2: 比如SHA-256、SHA-384和SHA-512，分别输出256,384,512bits
- SHA3：比如SHA3-256, SHA3-384, and SHA3-512

唯一显著的区别是SHA2容易受到 **长度扩展攻击**(*length extension attack*)

### 长度拓展攻击

给定$H(M)$和消息M的长度，在不知道M内容的情况下，攻击者控制消息M'可计算$H(M || M')$

- 该攻击适用 ^^消息与密钥的长度^^ 已知的情形下，采取H(密钥||消息)构造的散列函数

SHA-256 (SHA-2的256位版本)是脆弱的，而SHA-3并不脆弱

Q: 哈希能提供完整性吗?  -->  **取决于threat model**

如果攻击者可以修改散列，则不能提供完整性

!!! Example 
    Alice通过信道发送消息，并伴随着加密hash，Bob接收到该消息并计算该消息的哈希值，之后计算哈希是否与Alice发送的哈希相匹配，但信道存在Mallory，他可能修改消息和hash，故不能保证完整性

主要问题: 哈希是 *unkeyed(Without a key)* 函数

- 没有密钥被用作输入，因此任何攻击者都可以计算任何值的哈希值

哈希不提供完整性(除非可以安全地发布哈希)